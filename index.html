<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>olEDitor</title>
  <style>
    body {
      font-family: system-ui, Arial;
      margin: 12px;
      color: #e0e0e0;
      background: #181a1b;
    }
   /* allow pointer drawing (touch) on editor canvas */
    .row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    #screenWrap { position:relative; border:1px solid #333; background:transparent; width:fit-content; padding:0; }
    #screen { image-rendering:pixelated; display:block; background:transparent; }
    #ui { display:flex; gap:32px; margin-top:12px; align-items: flex-start; }
    #regionsList, #editor {
      border:1px solid #222;
      padding:8px;
      min-width:260px;
      max-width:420px;
      background:#232526;
      color: #e0e0e0;
    }
    button {
      padding:6px 8px;
      background: #222;
      color: #e0e0e0;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #333;
      border-color: #666;
    }
     .regionItem { display:flex; justify-content:space-between; gap:8px; padding:6px 4px; border-bottom:1px solid #eee; }
     label { font-size:13px; }
    input[type=number], input[type=text], input, select {
      width:80px;
      background: #181a1b;
      color: #e0e0e0;
      border: 1px solid #444;
      border-radius: 3px;
      padding: 4px;
    }
    input[type=text] { width: 100px; }
    input:focus, select:focus {
      outline: 1px solid #888;
      background: #222;
    }
     .small { font-size:12px; padding:4px 6px; }
    select { width:100%; background: #181a1b; color: #e0e0e0; border: 1px solid #444; }
     .muted { color:#888; font-size:12px; }
    .canvasEditor {
      border:1px solid #444;
      background:#181a1b;
      padding:6px;
      color:#e0e0e0;
      display:block;
      margin:0 auto;
      touch-action: none; /* important: enable pointermove on touch (tablets) */
    }
     /* Templates UI */
    .templatesList { margin-top:8px; border-top:1px dashed #333; padding-top:8px; }
    .templateItem {
      display:flex;
      justify-content:space-between;
      gap:8px;
      padding:6px 4px;
      border-bottom:1px solid #222;
      align-items:center;
      background:#232526;
      cursor:grab;
      color: #e0e0e0;
    }
    .templateItem:active { cursor:grabbing; }
    .templateDragHint { font-size:12px; color:#aaa; margin-top:6px; }
     #editor { flex: 1 1 0; min-width: 320px; max-width: none; }
     #editorContent { width: 100%; }
  </style>
</head>
<body>
  <div style="font-weight:700; font-size:18px; margin-bottom:8px; color:#e0e0e0;">olEDitor</div>
   <div class="row controls">
    <label>Screen W <input id="screenW" type="number" value="128" min="8" max="512"></label>
    <label>Screen H <input id="screenH" type="number" value="64" min="8" max="512"></label>
    <label>Scale <input id="screenScale" type="number" value="3" min="1" max="16"></label>
    <button id="clearRegions" class="small">Clear Regions</button>
    <button id="exportAll" class="small">Export .h (all regions/canvases)</button>
+    <button id="saveJson" class="small">Save JSON</button>
+    <button id="loadJson" class="small">Load JSON</button>
+    <input id="loadJsonFile" type="file" accept="application/json" style="display:none" />
    <div class="muted">Click on the screen to create a named region — or create templates, select one and click the preview to place it.</div>
  </div>

  <div id="screenWrap">
    <canvas id="screen"></canvas>
  </div>

  <div id="ui">
    <div id="regionsList">
      <div style="font-weight:700; margin-bottom:6px;">Regions</div>
      <div id="regionsContainer"></div>

      <!-- Templates / region sizes -->
      <div class="templatesList" id="templatesListWrap">
        <div style="font-weight:700; margin-bottom:6px;">Templates (define sizes and drag onto screen)</div>
        <div style="display:flex; gap:6px; margin-bottom:6px; align-items:center;">
          <input id="tmplName" placeholder="name" style="width:36%" />
          <input id="tmplW" type="number" placeholder="w" min="1" value="24" style="width:22%" />
          <input id="tmplH" type="number" placeholder="h" min="1" value="16" style="width:22%" />
          <button id="addTemplate" class="small">Add</button>
        </div>
        <div id="templatesContainer" class="muted">No templates yet.</div>
        <div class="templateDragHint muted">Select a template then click the preview to place it. Placed region will use the clicked position as the top-left corner (clamped to fit)</div>
      </div>

      <div class="muted" style="margin-top:8px;">Click a region's "Edit" to create canvases for that size. Use "Preview" to toggle a chosen canvas on-screen.</div>
    </div>

    <div id="editor">
      <div style="font-weight:700; margin-bottom:6px;">Editor</div>
      <div id="editorContent" class="muted">No region selected for editing.</div>
    </div>
  </div>

  <script>
    // Data structures
    const templates = []; // {id, name, w, h, canvases: [{name, pixels, w, h}]}
    const regions = []; // {id, name, x,y,w,h, templateId, previewIndex: int | null, previewOn: bool}
    let screenW = 128, screenH = 64, screenScale = 3;
    let selectedTemplateId = null;
    const screenCanvas = document.getElementById('screen');
    const screenCtx = screenCanvas.getContext('2d');

    // selection state
    let selecting = false;
    let selStart = null;
    let selRect = null;

    // editor state
    let editingRegionId = null;
    let editingCanvasIndex = null;

    // initialize
    function init() {
      screenW = +document.getElementById('screenW').value;
      screenH = +document.getElementById('screenH').value;
      screenScale = +document.getElementById('screenScale').value;
      resizeScreen();
      renderScreen();
      attachScreenEvents();
      renderRegionsList();
      bindControls();
      renderTemplatesList();

      // add a couple of example templates
      addTemplateObj({name:'button', w:24, h:16});
      addTemplateObj({name:'icon', w:16, h:16});
      renderTemplatesList();
    }

    function resizeScreen(){
      screenCanvas.width = screenW * screenScale;
      screenCanvas.height = screenH * screenScale;
      screenCanvas.style.width = (screenCanvas.width)+'px';
      screenCanvas.style.height = (screenCanvas.height)+'px';
    }

    function bindControls(){
      document.getElementById('screenW').addEventListener('change', ()=>{
        screenW = +document.getElementById('screenW').value; resizeScreen(); renderScreen();
      });
      document.getElementById('screenH').addEventListener('change', ()=>{
        screenH = +document.getElementById('screenH').value; resizeScreen(); renderScreen();
      });
      document.getElementById('screenScale').addEventListener('change', ()=>{
        screenScale = +document.getElementById('screenScale').value; resizeScreen(); renderScreen();
      });
      document.getElementById('clearRegions').addEventListener('click', ()=>{
        if(!confirm('Remove all regions and canvases?')) return;
        regions.length = 0; editingRegionId=null; editingCanvasIndex=null;
        renderRegionsList(); renderEditor(); renderScreen();
      });
      document.getElementById('exportAll').addEventListener('click', exportAllToHeader);
      document.getElementById('saveJson').addEventListener('click', ()=>{ saveProjectJson(); });
      document.getElementById('loadJson').addEventListener('click', ()=>{ document.getElementById('loadJsonFile').click(); });
      document.getElementById('loadJsonFile').addEventListener('change', (ev)=>{
        const f = ev.target.files && ev.target.files[0];
        if(!f) return;
        const reader = new FileReader();
        reader.onload = ()=> {
          try { loadProjectJson(reader.result); } catch(err){ alert('Invalid JSON: '+err.message); }
        };
        reader.readAsText(f);
        ev.target.value = '';
      });
      document.getElementById('addTemplate').addEventListener('click', ()=>{
        const name = (document.getElementById('tmplName').value || '').trim() || `tmpl_${templates.length+1}`;
        const w = Math.max(1, parseInt(document.getElementById('tmplW').value,10) || 1);
        const h = Math.max(1, parseInt(document.getElementById('tmplH').value,10) || 1);
        addTemplateObj({name, w, h});
        document.getElementById('tmplName').value=''; renderTemplatesList();
      });
    }

    function addTemplateObj(t){
      t.id = Date.now() + Math.floor(Math.random()*999);
      t.canvases = [];
      templates.push(t);
    }

    // Screen selection events: click to place selected template (top-left)
    function attachScreenEvents(){
      // Support placing a selected template by clicking the preview (click gives the top-left)
      const screenWrap = document.getElementById('screenWrap');
      screenWrap.addEventListener('click', e=>{
        if(!selectedTemplateId) return;
        const tmpl = templates.find(t=>t.id===selectedTemplateId);
        if(!tmpl) return;
        const rect = screenCanvas.getBoundingClientRect();
        const cx = Math.floor((e.clientX - rect.left) / screenScale);
        const cy = Math.floor((e.clientY - rect.top) / screenScale);
        // clamp so template fits fully on screen
        const x = clamp(cx, 0, Math.max(0, screenW - tmpl.w));
        const y = clamp(cy, 0, Math.max(0, screenH - tmpl.h));
        // bounds check: region must fit fully inside screen
        if (x < 0 || y < 0 || x + tmpl.w > screenW || y + tmpl.h > screenH) {
          alert('Region would be out of bounds. Please select a valid position.');
          return;
        }
        const id = Date.now() + Math.floor(Math.random()*999);
        const baseName = tmpl.name;
        let count = 1;
        let regionName = `${baseName}_${count}`;
        while (regions.some(r => r.name === regionName)) {
            count++;
            regionName = `${baseName}_${count}`;
        }
        const region = { id, name: regionName, x, y, w: tmpl.w, h: tmpl.h, templateId: tmpl.id, previewIndex: null, previewOn: false };
        regions.push(region);
        editingRegionId = id; editingCanvasIndex = null;
        // clear selection after placement
        selectedTemplateId = null;
        renderTemplatesList(); renderRegionsList(); renderEditor(); renderScreen();
      });
    }

    let dragDropActive = false;

    // Regions UI
    function renderRegionsList(){
      const container = document.getElementById('regionsContainer');
      container.innerHTML = '';
      if(regions.length===0){ container.innerHTML = '<div class="muted">No regions defined. Select a template and click on the screen to place one.</div>'; return; }
      regions.forEach((r, idx)=>{
        const div = document.createElement('div'); div.className='regionItem';
        const left = document.createElement('div');
        const nameDiv = document.createElement('div');
        nameDiv.style.fontWeight = '600';
        nameDiv.textContent = r.name;
        nameDiv.style.cursor = 'pointer';
        nameDiv.title = 'Click to rename';
        nameDiv.onclick = () => {
            const newName = prompt('Enter new name for the region:', r.name);
            if (newName && newName.trim()) {
                r.name = newName.trim();
                renderRegionsList();
                renderScreen();
                if (editingRegionId === r.id) {
                    renderEditor();
                }
            }
        };
        const detailsDiv = document.createElement('div');
        detailsDiv.className = 'muted';
        detailsDiv.textContent = `${r.w}x${r.h} @ ${r.x},${r.y}`;
        left.appendChild(nameDiv);
        left.appendChild(detailsDiv);
        const right = document.createElement('div');
        const editBtn = document.createElement('button'); editBtn.textContent='Edit'; editBtn.className='small';
        editBtn.onclick = ()=>{ editingRegionId = r.id; editingCanvasIndex = null; renderEditor(); renderScreen(); };
        const previewBtn = document.createElement('button'); previewBtn.textContent = r.previewOn ? 'Preview: ON' : 'Preview: OFF'; previewBtn.className='small';
        previewBtn.onclick = ()=>{ r.previewOn = !r.previewOn; renderRegionsList(); renderEditor(); renderScreen(); };
        // Populate preview dropdown from template canvases
        const tmpl = templates.find(t=>t.id===r.templateId);
        const choose = document.createElement('select'); choose.className='small';
        const defaultOpt = document.createElement('option'); defaultOpt.value='-1'; defaultOpt.textContent='(no canvas)'; choose.appendChild(defaultOpt);
        if (tmpl && tmpl.canvases.length > 0) {
          tmpl.canvases.forEach((c,i)=>{
            const o=document.createElement('option');
            o.value=i;
            o.textContent=c.name;
            if(r.previewIndex===i) o.selected=true;
            choose.appendChild(o);
          });
        }
        choose.onchange = ()=>{ const v = parseInt(choose.value,10); r.previewIndex = Number.isNaN(v) ? null : v; renderScreen(); };
        const delBtn = document.createElement('button'); delBtn.textContent='Delete'; delBtn.className='small';
        delBtn.onclick = ()=>{
          if(!confirm(`Delete region "${r.name}" and its canvases?`)) return;
          regions.splice(idx,1);
          if(editingRegionId===r.id){ editingRegionId=null; editingCanvasIndex=null; renderEditor(); }
          renderRegionsList(); renderScreen();
        };

        right.appendChild(editBtn);
        right.appendChild(previewBtn);
        right.appendChild(choose);
        right.appendChild(delBtn);
        div.appendChild(left); div.appendChild(right);
        container.appendChild(div);
      });
    }

    // Templates UI
    function renderTemplatesList(){
      const c = document.getElementById('templatesContainer');
      c.innerHTML = '';
      if(templates.length===0){ c.className='muted'; c.textContent='No templates yet.'; return; }
      c.className='';
      templates.forEach((t, i)=>{
        const div = document.createElement('div'); div.className='templateItem';
        div.innerHTML = `<div><strong>${t.name}</strong> <span class="muted">${t.w}x${t.h}</span></div>`;
        // visual selected state
        if(selectedTemplateId === t.id){
          div.style.outline = '2px solid #44aa44';
          div.style.background = '#eefef0';
        } else {
          div.style.outline = '';
          div.style.background = '';
        }
        // click to select this template for placement
        div.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          selectedTemplateId = (selectedTemplateId === t.id) ? null : t.id;
          renderTemplatesList();
        });
        const right = document.createElement('div');
        const del = document.createElement('button'); del.textContent='Del'; del.className='small';
        del.onclick = (ev)=>{
          ev.stopPropagation(); ev.preventDefault();
          // Find regions using this template
          const regionsUsing = regions.filter(r => r.templateId === t.id);
          let msg = `Remove template "${t.name}"?`;
          if(regionsUsing.length > 0){
            msg += `\n\nThis will also delete ${regionsUsing.length} region(s) that use this template.`;
          }
          if(!confirm(msg)) return;
          // Remove regions using this template
          for(let j=regions.length-1; j>=0; j--){
            if(regions[j].templateId === t.id){
              regions.splice(j,1);
            }
          }
          // Remove template
          templates.splice(i,1);
          // Reset editing state if needed
          if(selectedTemplateId === t.id) selectedTemplateId = null;
          if(editingRegionId && regions.findIndex(r=>r.id===editingRegionId) === -1){
            editingRegionId = null; editingCanvasIndex = null;
          }
          renderTemplatesList(); renderRegionsList(); renderEditor(); renderScreen();
        };
        right.appendChild(del);
        div.appendChild(right);

        c.appendChild(div);
      });
    }

    // Editor UI & behaviour
    function renderEditor(){
      const container = document.getElementById('editorContent');
      container.innerHTML = '';
      if(!editingRegionId){
        container.className='muted';
        container.textContent = 'No region selected for editing.';
        return;
      }
      const r = regions.find(rr=>rr.id===editingRegionId);
      if(!r){ editingRegionId=null; renderEditor(); return; }
      container.className='';
      // controls for canvases in region
      const header = document.createElement('div'); header.style.marginBottom='6px';
      // Title + numeric controls for top-left position so region can be moved precisely
      const title = document.createElement('div');
      title.style.fontWeight = '600';
      title.textContent = `${r.name} — ${r.w}x${r.h}`;
      header.appendChild(title);

      const posRow = document.createElement('div');
      posRow.style.marginTop = '6px';
      posRow.style.display = 'flex';
      posRow.style.gap = '8px';
      posRow.style.alignItems = 'center';

      const lbl = document.createElement('div'); lbl.className = 'muted'; lbl.style.fontSize='12px'; lbl.textContent = 'Top-left:';
      const inpX = document.createElement('input');
      inpX.type = 'number'; inpX.value = r.x; inpX.style.width = '80px';
      inpX.min = 0; inpX.max = Math.max(0, screenW - r.w);
      const inpY = document.createElement('input');
      inpY.type = 'number'; inpY.value = r.y; inpY.style.width = '80px';
      inpY.min = 0; inpY.max = Math.max(0, screenH - r.h);

      function applyPosFromInputs(){
        const nx = clamp(parseInt(inpX.value,10) || 0, 0, Math.max(0, screenW - r.w));
        const ny = clamp(parseInt(inpY.value,10) || 0, 0, Math.max(0, screenH - r.h));
        r.x = nx; r.y = ny;
        inpX.value = r.x; inpY.value = r.y;
        renderRegionsList(); renderScreen();
      }
      inpX.addEventListener('change', applyPosFromInputs);
      inpY.addEventListener('change', applyPosFromInputs);

      posRow.appendChild(lbl);
      posRow.appendChild(document.createTextNode('X'));
      posRow.appendChild(inpX);
      posRow.appendChild(document.createTextNode('Y'));
      posRow.appendChild(inpY);
      header.appendChild(posRow);
      container.appendChild(header);

     // Editor for template canvases
     const tmpl = templates.find(t=>t.id===r.templateId);
     if (!tmpl) return;
     const canvList = document.createElement('div');
     tmpl.canvases.forEach((c, ci)=>{
       const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.gap='6px'; row.style.padding='4px 0';
       const info = document.createElement('div'); info.innerHTML = `<div style="font-weight:600">${c.name}</div><div class="muted">${tmpl.w}x${tmpl.h}</div>`;
       const btns = document.createElement('div');
       const open = document.createElement('button'); open.textContent='Open'; open.className='small';
       open.onclick = ()=>{ editingCanvasIndex = ci; renderEditor(); };
       const rename = document.createElement('button'); rename.textContent='Rename'; rename.className='small';
       rename.onclick = ()=>{
         const nn = prompt('Canvas name:', c.name);
         if(nn){ c.name = nn; renderRegionsList(); renderEditor(); }
       };
       const remove = document.createElement('button'); remove.textContent='Remove'; remove.className='small';
       remove.onclick = ()=>{
         if(!confirm(`Remove canvas "${c.name}" ?`)) return;
         tmpl.canvases.splice(ci,1);
         if(editingCanvasIndex===ci) editingCanvasIndex=null;
         renderRegionsList(); renderEditor(); renderScreen();
       };
       btns.appendChild(open); btns.appendChild(rename); btns.appendChild(remove);
       row.appendChild(info); row.appendChild(btns);
       canvList.appendChild(row);
     });
     container.appendChild(canvList);

      const createRow = document.createElement('div'); createRow.style.marginTop='8px';
      const newNameInput = document.createElement('input'); newNameInput.placeholder='new canvas name'; newNameInput.style.width='60%';
      const newBtn = document.createElement('button'); newBtn.textContent='Create Canvas'; newBtn.className='small';
      newBtn.onclick = ()=>{
        const name = newNameInput.value.trim() || `canvas_${tmpl.canvases.length+1}`;
        const pix = new Array(tmpl.h).fill(0).map(()=> new Array(tmpl.w).fill(0));
        tmpl.canvases.push({ name, pixels: pix, w: tmpl.w, h: tmpl.h });
        editingCanvasIndex = tmpl.canvases.length-1;
        newNameInput.value='';
        renderRegionsList(); renderEditor(); renderScreen();
      };
      createRow.appendChild(newNameInput); createRow.appendChild(newBtn);
      container.appendChild(createRow);

      // if a canvas is open for editing, show editor area
     if(Number.isInteger(editingCanvasIndex) && tmpl.canvases[editingCanvasIndex]){
       const c = tmpl.canvases[editingCanvasIndex];
       const sep = document.createElement('div'); sep.style.marginTop='8px'; container.appendChild(sep);

        const editorWrap = document.createElement('div');
        editorWrap.innerHTML = `<div style="font-weight:600; margin-bottom:6px;">Editing "${c.name}"</div>`;
        const editorCanvas = document.createElement('canvas');
        // Scale the editor canvas to match the main display scale
        const eps = screenScale;
        editorCanvas.width = c.w * eps; editorCanvas.height = c.h * eps;
        editorCanvas.style.width = (c.w*eps)+'px'; editorCanvas.style.height = (c.h*eps)+'px';
        editorCanvas.className='canvasEditor';
        editorWrap.appendChild(editorCanvas);

        // editor controls
        const edControls = document.createElement('div'); edControls.style.marginTop='6px';
         const clearBtn = document.createElement('button'); clearBtn.textContent='Clear'; clearBtn.className='small';
         clearBtn.onclick = ()=>{ for(let y=0;y<c.h;y++) for(let x=0;x<c.w;x++) c.pixels[y][x]=0; renderEditor(); renderScreen(); };
         const invertBtn = document.createElement('button'); invertBtn.textContent='Invert'; invertBtn.className='small';
         invertBtn.onclick = ()=>{ for(let y=0;y<c.h;y++) for(let x=0;x<c.w;x++) c.pixels[y][x] = c.pixels[y][x] ? 0 : 1; renderEditor(); renderScreen(); };
         const exportBtn = document.createElement('button'); exportBtn.textContent='Export Canvas'; exportBtn.className='small';
         exportBtn.onclick = ()=>{ downloadHeaderForSingle(c, c.name); };
         edControls.appendChild(clearBtn); edControls.appendChild(invertBtn); edControls.appendChild(exportBtn);
         editorWrap.appendChild(edControls);

        container.appendChild(editorWrap);

        // attach drawing logic and render (simple draw mode only: left-click draws)
        attachEditorDrawing(editorCanvas, c, eps, ()=>{ renderEditor(); renderScreen(); } );
      }
    }
    
    function attachEditorDrawing(canvas, canvasObj, scale, onChange, getDrawValue){
      // Attach stable handlers once. handlers will query the current canvas object via
      // a getter stored on the canvas element so re-rendering doesn't rebind listeners.
      canvas._getCanvasObj = () => canvasObj;
 
       const ctx = canvas.getContext('2d');

      function render(){
        const cur = (typeof canvas._getCanvasObj === 'function') ? canvas._getCanvasObj() : canvasObj;
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        for(let y=0;y<cur.h;y++){
          for(let x=0;x<cur.w;x++){
            if(cur.pixels[y][x]){
              ctx.fillStyle = '#fff';
              ctx.fillRect(x*scale, y*scale, scale, scale);
            } else {
              ctx.fillStyle = '#202020';
              ctx.fillRect(x*scale, y*scale, scale, scale);
            }
          }
        }
        // grid
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.beginPath();
        for(let x=0;x<=cur.w;x++){ ctx.moveTo(x*scale+0.5,0); ctx.lineTo(x*scale+0.5, canvas.height); }
        for(let y=0;y<=cur.h;y++){ ctx.moveTo(0,y*scale+0.5); ctx.lineTo(canvas.width, y*scale+0.5); }
        ctx.stroke();
      }

      function toggleAt(cur, e){
        const rect = canvas.getBoundingClientRect();
        const ps = scale;
        const x = Math.floor((e.clientX - rect.left) / ps - 0.5);
        const y = Math.floor((e.clientY - rect.top) / ps - 0.5);
        if(x>=0 && x<cur.w && y>=0 && y<cur.h){
          cur.pixels[y][x] = 1;
          render();
        }
      }
      
      // stable per-canvas state
      if(!canvas._handlersAttached){
        canvas._drawing = false;

        const down = (e) => {
          canvas._drawing = true;
          canvas.setPointerCapture(e.pointerId);
          // simple behaviour: left-click draws (1), other buttons clear (0)
          const cur = canvas._getCanvasObj();
          toggleAt(cur, e);
        };

        const move = (e) => {
          if(!canvas._drawing) return;
          const cur = canvas._getCanvasObj();
          toggleAt(cur, e);
        };

        const up = (e) => {
          canvas._drawing = false;
          canvas.releasePointerCapture(e.pointerId);
        };

        canvas.addEventListener('pointerdown', down, { passive: false });
        canvas.addEventListener('pointermove', move, { passive: false });
        canvas.addEventListener('pointerup', up, { passive: false });
        canvas.addEventListener('pointercancel', up, { passive: false });

        canvas._handlersAttached = true;
      } else {
        // update getter to point at the new object (no rebind)
        canvas._getCanvasObj = () => canvasObj;
      }

       // initial draw
       render();
     }

    // Utils
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function sanitize(input) {
      // Replace all invalid characters with underscores
      let sanitized = input.replace(/[^a-zA-Z0-9_]/g, '_');

      // If the first character is a number, prepend an underscore
      if (sanitized.match(/^[0-9]/)) {
          sanitized = '_' + sanitized;
      }

      return sanitized;
    }

    // Export functions
    function packFrameBytes(pixels, w, h){
      const paddedH = Math.ceil(h/8)*8;
      const pages = paddedH/8;
      const out = [];
      for(let x=0;x<w;x++){
        for(let page=0; page<pages; page++){
          let b = 0;
          for(let bit=0; bit<8; bit++){
            const y = page*8 + bit;
            if(y < h && pixels[y][x]) b |= (1<<bit);
          }
          out.push(b);
        }
      }
      return { bytes: out, w, h: paddedH };
    }

    // Fix: Render the canvas preview on the main screen using template canvases
function renderScreen(){
  // clear
  screenCtx.fillStyle = '#000'; screenCtx.fillRect(0,0,screenCanvas.width,screenCanvas.height);

  // optional faint grid (per-pixel)
  screenCtx.strokeStyle = '#0d0d0d';
  screenCtx.lineWidth = 1;
  const ps = screenScale;
  for(let x=0;x<=screenW;x++){
    screenCtx.beginPath();
    screenCtx.moveTo(x*ps+0.5,0);
    screenCtx.lineTo(x*ps+0.5,screenCanvas.height);
    screenCtx.stroke();
  }
  for(let y=0;y<=screenH;y++){
    screenCtx.beginPath();
    screenCtx.moveTo(0,y*ps+0.5);
    screenCtx.lineTo(screenCanvas.width,y*ps+0.5);
    screenCtx.stroke();
  }

  // draw region previews (if enabled)
  regions.forEach(r=>{
    // region background
    screenCtx.fillStyle = 'rgba(80,80,120,0.06)';
    screenCtx.fillRect(r.x*ps, r.y*ps, r.w*ps, r.h*ps);

    // border
    screenCtx.strokeStyle = r.id === editingRegionId ? '#ff8800' : '#66aaff';
    screenCtx.lineWidth = 2;
    screenCtx.strokeRect(r.x*ps+1, r.y*ps+1, r.w*ps-2, r.h*ps-2);

    // name label
    screenCtx.fillStyle = '#fff';
    screenCtx.font = `${Math.max(10,ps*2)}px monospace`;
    screenCtx.fillText(r.name || ('r'+r.id), r.x*ps+4, r.y*ps+Math.min(16, ps*3));

    // Fix: Use template canvases for preview
    const tmpl = templates.find(t=>t.id===r.templateId);
    if(r.previewOn && tmpl && Number.isInteger(r.previewIndex) && tmpl.canvases[r.previewIndex]){
      drawCanvasPixelsOnScreen(tmpl.canvases[r.previewIndex], r.x, r.y);
    }
  });
}

// Fix: drawCanvasPixelsOnScreen must exist
function drawCanvasPixelsOnScreen(canvasObj, offsetX, offsetY){
  const ps = screenScale;
  const pix = canvasObj.pixels;
  for(let y=0;y<canvasObj.h;y++){
    for(let x=0;x<canvasObj.w;x++){
      if(pix[y][x]){
        screenCtx.fillStyle = '#fff';
        screenCtx.fillRect((offsetX + x)*ps, (offsetY + y)*ps, ps, ps);
      }
    }
  }
}

// Fix: Export buttons must work with template canvases
function exportAllToHeader(){
  const screenH_pages = Math.ceil(screenH/8);
  let header = `// Generated by olEDitor (Ed Diamond, 2025)\n#include <Arduino.h>\n\n`;
  
  // 1. Add struct definition
  header += `typedef struct {\n    uint8_t width;\n    uint8_t height;\n    const uint8_t *data;\n} oled_canvas;\n\n`;

  header += `// a region on the screen for drawing\nstruct region {\n    uint8_t x;\n    uint8_t y;\n    uint8_t width;\n    uint8_t height;\n};\n\n`;

  header += `// a struct to represent the screen itself\n`;
  header += `struct oled_screen {\n`;
  header += `    const uint8_t width;\n`;
  header += `    const uint8_t height;\n`;
  header += `    uint8_t buffer[${screenW} * ${screenH_pages}];\n`;
  header += `};\n\n`;

  header += `// Copies a canvas to a specified region on the screen, respecting position.\n`;
  header += `static void displayCanvas(struct oled_screen* screen, const struct region* region, const oled_canvas* canvas) {\n`;
  header += `    if (!screen || !region || !canvas || !canvas->data) return;\n\n`;
  header += `    const uint8_t screen_h_pages = screen->height / 8;\n\n`;
  header += `    for (uint8_t cx = 0; cx < canvas->width; cx++) {\n`;
  header += `        for (uint8_t cy = 0; cy < canvas->height; cy++) {\n`;
  header += `            uint8_t screen_x = region->x + cx;\n`;
  header += `            uint8_t screen_y = region->y + cy;\n\n`;
  header += `            if (screen_x >= screen->width || screen_y >= screen->height) continue;\n\n`;
  header += `            // Get pixel from canvas (data is in PROGMEM)\n`;
  header += `            uint16_t canvas_byte_offset = cx * (canvas->height / 8) + (cy / 8);\n`;
  header += `            uint8_t canvas_bit_offset = cy % 8;\n`;
  header += `            uint8_t canvas_byte = pgm_read_byte(&canvas->data[canvas_byte_offset]);\n`;
  header += `            uint8_t pixel_is_on = (canvas_byte >> canvas_bit_offset) & 1;\n\n`;
  header += `            // Set pixel on screen\n`;
  header += `            uint16_t screen_byte_offset = screen_x * screen_h_pages + (screen_y / 8);\n`;
  header += `            uint8_t screen_bit_offset = screen_y % 8;\n\n`;
  header += `            if (pixel_is_on) {\n`;
  header += `                screen->buffer[screen_byte_offset] |= (1 << screen_bit_offset);\n`;
  header += `            } else {\n`;
  header += `                screen->buffer[screen_byte_offset] &= ~(1 << screen_bit_offset);\n`;
  header += `            }\n`;
  header += `        }\n`;
  header += `    }\n`;
  header += `}\n\n`;

  let canvas_struct_definitions = '';
  const canvas_map = new Map();

  // 2. Generate structs with compound literal for data
  canvas_struct_definitions += `// -- Canvas Structs --\n`;

  templates.forEach((tmpl, ti) => {
    tmpl.canvases.forEach((c, ci) => {
      const p = packFrameBytes(c.pixels, c.w, c.h);
      const base_name = `${sanitize(tmpl.name)}_${sanitize(c.name)}`;
      const struct_name = `${base_name}`;

      // Struct definition with compound literal
      canvas_struct_definitions += `const oled_canvas ${struct_name} PROGMEM = {\n`;
      canvas_struct_definitions += `    ${p.w}, // width\n`;
      canvas_struct_definitions += `    ${p.h}, // height\n`;
      canvas_struct_definitions += `    (const uint8_t[]){\n        `;
      
      p.bytes.forEach((b, idx)=>{
        canvas_struct_definitions += '0x' + b.toString(16).padStart(2,'0').toUpperCase();
        if(idx < p.bytes.length-1) canvas_struct_definitions += ', ';
        if((idx+1)%16===0 && idx < p.bytes.length - 1) canvas_struct_definitions += '\n        ';
      });

      canvas_struct_definitions += `\n    }\n};\n\n`;
      
      // Store canvas details for region export
      canvas_map.set(`${tmpl.id}_${ci}`, {
          struct_name: struct_name,
      });
    });
  });

  header += canvas_struct_definitions;

  // 3. Generate region structs
  if (regions.length > 0) {
      header += `// Pre-defined regions for drawing\n`;
      regions.forEach(r => {
        const sanitized_name = sanitize(r.name);
        header += `const struct region ${sanitized_name} PROGMEM = { .x = ${r.x}, .y = ${r.y}, .width = ${r.w}, .height = ${r.h} };\n`;
      });
      header += `\n`;
  }

  downloadText('screen_images.h', header);
}

function downloadHeaderForSingle(canvasObj, canvasName){
  const p = packFrameBytes(canvasObj.pixels, canvasObj.w, canvasObj.h);
  const name = sanitize(canvasName);
  let header = `// canvas "${canvasName}" (${canvasObj.w}x${canvasObj.h})\n#include <stdint.h>\n\n`;
  header += `// a region on the screen for drawing\nstruct region {\n    uint8_t height;\n    uint8_t width;\n    uint16_t offset; // byte offset into screen buffer\n};\n\n`;
  header += `const uint8_t ${name}_width = ${p.w};\nconst uint8_t ${name}_height = ${p.h};\n`;
  header += `const uint8_t ${name}[] PROGMEM = { \n    `;
  p.bytes.forEach((b, idx)=>{
    header += '0x' + b.toString(16).padStart(2,'0').toUpperCase();
    if(idx < p.bytes.length-1) header += ', ';
    if((idx+1)%16===0) header += '\n    ';
  });
  header += '\n};\n';
  downloadText(name + '.h', header);
}

// --- Save / Load JSON + sanitization helpers ---
// small helper to download text
function downloadText(filename, text){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type:'application/json'}));
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function sanitizeName(n, fallback='unnamed'){
  if(typeof n !== 'string') n = fallback;
  n = n.trim().replace(/\s+/g,' ').slice(0,64);
  // replace control chars and many punctuation with underscore
  n = n.replace(/[^\w\d \-\.]/g, '_');
  if(n.length === 0) n = fallback;
  return n;
}

function sanitizePixels(raw, w, h){
  // produce array [h][w] of 0/1
  const out = new Array(h);
  for(let y=0;y<h;y++){
    out[y] = new Array(w).fill(0);
  }
  if(!Array.isArray(raw)) return out;
  for(let y=0;y<Math.min(h, raw.length); y++){
    const row = Array.isArray(raw[y]) ? raw[y] : [];
    for(let x=0;x<Math.min(w, row.length); x++){
      out[y][x] = row[x] ? 1 : 0;
    }
  }
  return out;
}

function saveProjectJson(){
  const payload = {
    meta: { exportedAt: (new Date()).toISOString() },
    templates: templates.map(t => ({
      id: t.id,
      name: sanitizeName(t.name),
      w: Number(t.w) || 1,
      h: Number(t.h) || 1,
      canvases: (Array.isArray(t.canvases) ? t.canvases : []).map(c => ({
        name: sanitizeName(c.name),
        pixels: c.pixels
      }))
    })),
    regions: regions.map(r => ({
      id: r.id,
      name: sanitizeName(r.name),
      x: Number(r.x) || 0,
      y: Number(r.y) || 0,
      templateId: r.templateId,
      previewIndex: Number.isInteger(r.previewIndex) ? r.previewIndex : null,
      previewOn: !!r.previewOn
    }))
  };
  downloadText(`oled_project_${Date.now()}.json`, JSON.stringify(payload, null, 2));
}

function loadProjectJson(text){
  let doc;
  try { doc = JSON.parse(text); } catch(e){ throw new Error('JSON parse failed'); }
  if(!doc || typeof doc !== 'object') throw new Error('Invalid JSON structure');
  const incomingTemplates = Array.isArray(doc.templates) ? doc.templates : [];
  const incomingRegions = Array.isArray(doc.regions) ? doc.regions : [];

  // build new templates with fresh ids and sanitized content
  const idMap = new Map(); // oldId -> newId
  const newTemplates = [];
  for(let i=0;i<incomingTemplates.length;i++){
    const t = incomingTemplates[i];
    const name = sanitizeName(t.name || `tmpl_${i+1}`);
    const w = Math.max(1, Math.min(512, parseInt(t.w,10) || 1));
    const h = Math.max(1, Math.min(512, parseInt(t.h,10) || 1));
    const newId = Date.now() + Math.floor(Math.random()*9999) + i;
    idMap.set(t.id, newId);
    const canvases = [];
    const rawCanvases = Array.isArray(t.canvases) ? t.canvases : [];
    for(let ci=0; ci<rawCanvases.length; ci++){
      const rc = rawCanvases[ci];
      const cname = sanitizeName(rc.name || `canvas_${ci+1}`);
      const pixels = sanitizePixels(rc.pixels, w, h);
      canvases.push({ name: cname, pixels, w, h });
    }
    newTemplates.push({ id: newId, name, w, h, canvases });
  }

  // build new regions, map template ids, clamp positions
  const newRegions = [];
  for(let i=0;i<incomingRegions.length;i++){
    const r = incomingRegions[i];
    const name = sanitizeName(r.name || `region_${i+1}`);
    const oldTid = r.templateId;
    const mappedTid = idMap.get(oldTid);
    if(!mappedTid){
      // skip regions that reference unknown templates
      console.warn('Skipping region referencing unknown template id', oldTid);
      continue;
    }
    const tmpl = newTemplates.find(t=>t.id===mappedTid);
    if(!tmpl) continue;
    const w = tmpl.w, h = tmpl.h;
    const x = clamp(Math.floor(Number(r.x) || 0), 0, Math.max(0, screenW - w));
    const y = clamp(Math.floor(Number(r.y) || 0), 0, Math.max(0, screenH - h));
    const previewIndex = Number.isInteger(r.previewIndex) ? Math.max(0, r.previewIndex) : null;
    const previewOn = !!r.previewOn;
    const newId = Date.now() + Math.floor(Math.random()*9999) + i + 10000;
    newRegions.push({ id: newId, name, x, y, w, h, templateId: mappedTid, previewIndex: (tmpl.canvases[previewIndex] ? previewIndex : null), previewOn });
  }

  // apply new data
  templates.length = 0; templates.push(...newTemplates);
  regions.length = 0; regions.push(...newRegions);
  editingRegionId = null; editingCanvasIndex = null;
  renderTemplatesList(); renderRegionsList(); renderEditor(); renderScreen();
  alert(`Loaded project: ${templates.length} templates, ${regions.length} regions`);
}
    // start
    init();
  </script>
</body>
</html>